<!DOCTYPE html>

<html lang="en">
	<head>
		<title>Aaeria | Widgets</title>
		<link rel="icon" href="assets/images/logo.ico" type="image/icon">
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="stylesheet" href="assets/styles.css" type="text/css">
		<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous">
	</head>
	<body>
		<header>
			<h1><a href="index.html">Widgets</a></h1>
			<a href="https://aaeria.me"><img src="assets/images/logo.ico" alt="logo"></a>
		</header>
		<div class="main">
			<a href="index.html">Back</a>
			<h1>Convex Hull</h1>
			<button onclick="genRandom()">Reset</button>
			Mouse Mode:
			<select onchange="mouseOption(event)">
				<option value="drag">Drag</option>
				<option value="create">Create</option>
				<option value="erase">Erase</option>
			</select>
			Movement Type:
			<select onchange="moveOption(event)">
				<option value="frozen">Frozen</option>
				<option value="slow">Slow</option>
				<option value="free">Free</option>
				<option value="elastic">Elastic</option>
			</select>
			<button onclick="genHull(true)">Regenerate Hull</button>

			<canvas id="canvas"></canvas>
			<p>
				Gift wrapping/minimum enclosing fence. Uses O(nlogn) convex hull algorithm.
				Click Regenerate Hull while in Frozen mode to see the algorithm run.
				In Elastic mode, the hull tries to contract, applying a force like a real rubber band.
				You can also drag the dots around.
			</p>
		</div>
		<footer>
			<a href="https://github.com/zzaria/widgets"><i class="fab fa-github"></i></a>
			<div class="bottom">
				<p>2020 | <a href="https://aaeria.me">Aaeria</a></p>
			</div>
		</footer>
	</body>
	<script>
		var canvas=document.getElementById("canvas"),canv=canvas.getContext("2d"),W=window.innerWidth*0.7,H=window.innerHeight*0.6;
		var n=0,p=[],h=0,hull=[],inHull=[],curDrag=null,drawNum=0,mouseType="drag",moveType="frozen";
		canvas.width=W
		canvas.height=H;
		canvas.onmousedown=beginDrag;
		canvas.onmouseup=endDrag;
		setInterval(move,10);
		while(n<5){
			genRandom();
		}
		function sleep(ms) {
		  return new Promise(resolve => setTimeout(resolve, ms));
		}
		function drawCircle(p){
			canv.beginPath();
			canv.arc(p[0],p[1],n>25? 5:10,0,2*Math.PI);
			canv.fill();
			canv.stroke();
		}
		function drawLine(p1,p2){
			canv.beginPath();
			canv.moveTo(p1[0],p1[1]);
			canv.lineTo(p2[0],p2[1]);
			canv.stroke();
		}
		function cross(p0,p1,p2){
			return (p1[0]-p0[0])*(p2[1]-p0[1])-(p1[1]-p0[1])*(p2[0]-p0[0]);
		}
		function calcDist(p1,p2){
			return Math.sqrt((p1[0]-p2[0])*(p1[0]-p2[0])+(p1[1]-p2[1])*(p1[1]-p2[1]));
		}
		function drawHull(){
			canv.clearRect(0,0,W,H);
			h=hull.length;
			canv.lineWidth=(n>25? 1:5);
			canv.strokeStyle="black";
			canv.fillStyle="black";
			for(let i=0;i<p.length;i++)
				drawCircle(p[i]);
			canv.strokeStyle="red";
			for(let i=0;i<h;i++) drawLine(hull[i],hull[(i+1)%h]);
			canv.strokeStyle="black";
			canv.fillStyle="yellow";
			for(let i=0;i<h;i++)
				drawCircle(hull[i]);
			canv.fillStyle="black";
			canv.fillText("Count: "+n,5,10);
		}
		async function genHull(slow){
			if(n===0){
				canv.clearRect(0,0,W,H);
				return;
			}
			var dragP=null,curNum=++drawNum;
			hull=[]
			if(curDrag!=null) dragP=p[curDrag];
			for(let i=0;i<n-1;i++) 
				if(p[i][0]<p[n-1][0]||p[i][0]===p[n-1][0]&&p[i][1]<p[n-1][1])
					[p[i],p[n-1]]=[p[n-1],p[i]];
			hull[0]=p.pop(); inHull=[n-1];
			p.sort(function(a,b){
				return -cross(hull[0],a,b);
			});
			p.push(hull[0]);
			for(let i=0;i<n-1;i++){
				while(hull.length>1&&cross(hull[hull.length-1],p[i],hull[hull.length-2])<0||p[i][0]===hull[hull.length-1][0]&&p[i][1]===hull[hull.length-1][1]){
					if(curNum!==drawNum) return;
					if(slow){
						drawHull();
						drawLine(p[i],hull[hull.length-1]);
						await sleep(n>25? 400:700);
					}
					hull.pop(); inHull.pop();
				}
				if(curNum!==drawNum) return;
				hull.push(p[i]); inHull.push(i);
				if(slow){
					drawHull();
					await sleep(n>25? 400:700);
				}
			}
			if(dragP!=null) 
				for(let i=0;i<n;i++) if(p[i][0]===dragP[0]&&p[i][1]===dragP[1]&&p[i][2]===dragP[2]&&p[i][3]===dragP[3]) curDrag=i;
			drawHull();
		}
		function genRandom(){
			n=Math.random()*10,p=[]; n=Math.floor(n*n)+1;
			for(let i=0;i<n;i++)
				p.push([Math.floor(Math.random()*W),Math.floor(Math.random()*H),Math.random()*W/50-W/100,Math.random()*H/50-H/100]);
			genHull();
		}
		function beginDrag(e){
			canvas.onmousemove=dragDot;
			var x=e.x-canvas.offsetLeft,y=e.y-canvas.offsetTop,dist=200;
			for(let i=0;i<n;i++)
				if((x-p[i][0])*(x-p[i][0])+(y-p[i][1])*(y-p[i][1])<dist){
					dist=(x-p[i][0])*(x-p[i][0])+(y-p[i][1])*(y-p[i][1]);
					curDrag=i;
				}
		}
		function endDrag(e){
			curDrag=null;
			canvas.onmousemove=null;
		}
		function dragDot(e){
			if(curDrag===null) return;
			var x=e.x-canvas.offsetLeft,y=e.y-canvas.offsetTop;
			p[curDrag]=[x,y,0,0];
			genHull();
		}
		function createDot(e){
			console.log(1);
			var x=e.x-canvas.offsetLeft,y=e.y-canvas.offsetTop;
			p.push([x,y,Math.random()*W/50-W/100,Math.random()*H/50-H/100]); n++;
			genHull();
		}
		function eraseDot(e){
			var x=e.x-canvas.offsetLeft,y=e.y-canvas.offsetTop,dist=200,toDelete=null;
			for(let i=0;i<n;i++)
				if((x-p[i][0])*(x-p[i][0])+(y-p[i][1])*(y-p[i][1])<dist){
					dist=(x-p[i][0])*(x-p[i][0])+(y-p[i][1])*(y-p[i][1]);
					toDelete=i;
				}
			if(toDelete!==null) p.splice(toDelete,1);
			n=p.length;
			genHull();
		}
		function mouseOption(e){
			mouseType=e.target.value;
			if(mouseType==="drag"){
				canvas.onmousedown=beginDrag;
				canvas.onmouseup=endDrag;
			}
			else if(mouseType==="create"){
				canvas.onmousedown=createDot;
				canvas.onmouseup=null;
			}
			else if(mouseType==="erase"){
				canvas.onmousedown=eraseDot;
				canvas.onmouseup=null;
			}
		}
		function move(){
			if(moveType==="frozen") return;
			for(let i=0;i<n;i++){
				if(p[i][0]<0&&p[i][2]<0) p[i][2]*=-1;
				else if(p[i][0]>W&&p[i][2]>0) p[i][2]*=-1;
				if(p[i][1]<0&&p[i][3]<0) p[i][3]*=-1;
				else if(p[i][1]>H&&p[i][3]>0) p[i][3]*=-1;
				if(moveType==="free"){
					p[i][0]+=p[i][2];
					p[i][1]+=p[i][3];
				}
				else{
					p[i][0]+=p[i][2]/5;
					p[i][1]+=p[i][3]/5;
				}
			}
			if(moveType==="elastic"){
				h=hull.length,len=0;
				for(let i=0;i<h;i++) len+=calcDist(hull[i],hull[(i+1)%h]);
				len/=1000;
				for(let i=0;i<h;i++){
					let x=hull[(i+1)%h][0]+hull[(i-1+h)%h][0]-2*hull[i][0],y=hull[(i+1)%h][1]+hull[(i-1+h)%h][1]-2*hull[i][1];
					if(p[inHull[i]][0]<0||p[inHull[i]][1]<0||p[inHull[i]][0]>W||p[inHull[i]][1]>H) continue;
					p[inHull[i]][2]+=x*len/2000; p[inHull[i]][3]+=y*len/2000;
					p[inHull[i]][2]*=n>25? 0.995: 0.9995; p[inHull[i]][3]*=n>25? 0.995: 0.9995;
				}
			}
			genHull();
		}
		function moveOption(e){
			moveType=e.target.value;
		}
	</script>
</html>